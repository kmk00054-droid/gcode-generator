<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>G-Code Generator — Image to 2D G-Code</title>
  <style>
    :root{
      --bg:#0f1720;
      --card:#0b1220;
      --accent:#7dd3fc;
      --muted:#94a3b8;
      --mono: #e6eef6;
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Arial;background:linear-gradient(180deg,#071025 0%, #071826 60%);color:var(--mono)}
    .wrap{max-width:980px;margin:28px auto;padding:20px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
    h1{margin:0 0 12px;font-size:20px}
    p.lead{color:var(--muted);margin:0 0 16px}
    .cols{display:grid;grid-template-columns:320px 1fr;gap:18px}
    .card{background:var(--card);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
    label{display:block;font-size:13px;margin-bottom:6px;color:var(--muted)}
    input[type=file]{width:100%}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .controls > *{flex:1 1 auto;min-width:80px}
    canvas{background:#fff;border:1px solid rgba(0,0,0,0.08);width:100%;height:auto;display:block}
    .small{font-size:13px;color:var(--muted)}
    .muted{color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    button{background:linear-gradient(180deg,var(--accent),#26b6e8);border:none;color:#04202a;padding:8px 10px;border-radius:6px;cursor:pointer;font-weight:600}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--mono)}
    textarea{width:100%;height:360px;background:#02111b;color:var(--mono);border-radius:8px;padding:12px;border:1px solid rgba(255,255,255,0.03);resize:vertical;font-family:monospace;font-size:12px;line-height:1.4}
    .preview-wrap{display:grid;grid-template-rows:auto 1fr;gap:8px}
    .meta{display:flex;gap:8px;align-items:center;justify-content:space-between}
    .note{font-size:12px;color:var(--muted)}
    .footer{margin-top:14px;color:var(--muted);font-size:13px}
    .controls label.inline{margin:0;font-size:13px}
    .flex{display:flex;gap:8px}
    .download{display:inline-flex;gap:8px;align-items:center}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Image → 2D G-Code (Static Web Page)</h1>
    <p class="lead">Upload a small PNG/JPG (black-and-white or grayscale). The page converts it to a monochrome grid, previews it, and generates simple GRBL-style G-Code for an XY plotter. No backend — works on GitHub Pages.</p>

    <div class="cols">
      <div class="card">
        <label>Image (PNG / JPG)</label>
        <input id="file" type="file" accept="image/png,image/jpeg" />

        <div style="height:8px"></div>

        <label class="inline">Threshold: <span id="thVal">128</span></label>
        <input id="threshold" type="range" min="0" max="255" value="128" />

        <div style="height:8px"></div>

        <label class="inline">Output Width (mm)</label>
        <input id="widthMM" type="number" min="1" step="1" value="60" />

        <div style="height:8px"></div>

        <label class="inline">Max Image Pixels (largest dimension)</label>
        <input id="maxPx" type="number" min="16" step="1" value="200" />

        <div style="height:8px"></div>

        <label class="inline">Mode</label>
        <div class="controls">
          <select id="mode">
            <option value="raster">Raster (horizontal runs)</option>
            <option value="contour">Contour (outline tracing — simple)</option>
          </select>
          <button id="processBtn" class="ghost">Process</button>
        </div>

        <div style="height:12px"></div>

        <div class="row">
          <button id="generateBtn">Generate G-Code</button>
          <button id="downloadBtn" class="ghost" disabled>Download .gcode</button>
        </div>

        <div style="height:12px"></div>

        <div class="note">Travel Z (pen up): +5 mm. Draw Z (pen down): 0 mm. Units: mm (G21). Feedrate (draw): 1500 mm/min. Rapid moves use G0.</div>
      </div>

      <div>
        <div class="card preview-wrap">
          <div class="meta">
            <div>
              <label class="small">Preview (processed)</label>
            </div>
            <div class="muted small" id="infoSize">—</div>
          </div>
          <canvas id="previewCanvas" width="300" height="300"></canvas>
        </div>

        <div style="height:12px"></div>

        <div class="card">
          <div class="meta" style="margin-bottom:8px">
            <label class="small">G-Code</label>
            <div class="muted small">Preview and edit before download</div>
          </div>
          <textarea id="gcodeText" readonly></textarea>
        </div>
      </div>
    </div>

    <div class="footer">Tip: upload a simple black square or outline as a test. Use "Raster" mode for filled shapes. Use "Contour" for single-pixel-thick outlines (results vary).</div>
  </div>

  <script>
    // UI refs
    const fileEl = document.getElementById('file');
    const previewCanvas = document.getElementById('previewCanvas');
    const pctx = previewCanvas.getContext('2d');
    const thresholdEl = document.getElementById('threshold');
    const thVal = document.getElementById('thVal');
    const maxPxEl = document.getElementById('maxPx');
    const widthMMEl = document.getElementById('widthMM');
    const processBtn = document.getElementById('processBtn');
    const generateBtn = document.getElementById('generateBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const gcodeText = document.getElementById('gcodeText');
    const modeEl = document.getElementById('mode');
    const infoSize = document.getElementById('infoSize');

    let img = new Image();
    let binary = null;
    let imgW = 0, imgH = 0;
    let lastGcode = '';

    thresholdEl.addEventListener('input', ()=>thVal.textContent = thresholdEl.value);
    fileEl.addEventListener('change', handleFile);
    processBtn.addEventListener('click', doProcess);
    generateBtn.addEventListener('click', generateGcode);
    downloadBtn.addEventListener('click', downloadGcode);

    function handleFile(){
      const f = fileEl.files && fileEl.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      img = new Image();
      img.onload = () => {
        // resize to max dimension
        const maxDim = Number(maxPxEl.value) || 200;
        let w = img.width, h = img.height;
        const scale = Math.min(1, maxDim / Math.max(w,h));
        w = Math.max(1, Math.round(w * scale));
        h = Math.max(1, Math.round(h * scale));
        imgW = w; imgH = h;
        previewCanvas.width = w;
        previewCanvas.height = h;
        pctx.drawImage(img, 0, 0, w, h);
        infoSize.textContent = `${w} x ${h}px`;
        // auto-process small images
        doProcess();
        URL.revokeObjectURL(url);
      };
      img.onerror = () => { alert('Could not load image'); URL.revokeObjectURL(url); };
      img.src = url;
    }

    function doProcess(){
      if(!img || !img.width) {
        alert('Please upload an image first.');
        return;
      }
      // draw original scaled image into canvas
      pctx.drawImage(img, 0, 0, previewCanvas.width, previewCanvas.height);
      const w = previewCanvas.width, h = previewCanvas.height;
      const id = pctx.getImageData(0,0,w,h);
      const data = id.data;
      const th = Number(thresholdEl.value);
      binary = new Uint8Array(w*h);
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const i = (y*w + x)*4;
          // luminance
          const r = data[i], g = data[i+1], b = data[i+2];
          const lum = 0.2126*r + 0.7152*g + 0.0722*b;
          const isBlack = lum < th ? 1 : 0; // treat dark as "ink"
          binary[y*w + x] = isBlack;
          const col = isBlack ? 0 : 255;
          data[i]=data[i+1]=data[i+2]=col;
          data[i+3]=255;
        }
      }
      pctx.putImageData(id,0,0);
      infoSize.textContent = `${w} x ${h}px — ${countOnes(binary)} black pixels`;
      lastGcode = '';
      gcodeText.value = '';
      downloadBtn.disabled = true;
    }

    function countOnes(arr){
      let n=0;
      for(let i=0;i<arr.length;i++) if(arr[i]) n++;
      return n;
    }

    // GENERATE G-CODE (raster or contour)
    function generateGcode(){
      if(!binary) { alert('Process an image first'); return; }
      const mode = modeEl.value;
      const widthMM = Number(widthMMEl.value) || 60;
      const w = previewCanvas.width, h = previewCanvas.height;
      const pixelMM = widthMM / w;
      const heightMM = pixelMM * h;
      const feedDraw = 1500;
      const feedTravel = 3000;
      const zUp = 5;
      const zDown = 0;
      const lines = [];
      lines.push('; Generated by static image→GCode generator');
      lines.push('G21 ; units in mm');
      lines.push('G90 ; absolute');
      lines.push(`; Image size: ${w} x ${h} px -> ${widthMM.toFixed(2)} x ${heightMM.toFixed(2)} mm`);
      lines.push(`F${feedDraw} ; draw feedrate`);
      // start with pen up
      lines.push(`G0 Z${zUp.toFixed(2)} F${feedTravel}`);
      // coordinate mapping: image (0,0) top-left -> X=0..widthMM, Y=0..heightMM (flip Y to have origin bottom-left if required)
      // We'll map image y=0 to Y=0 (top) to keep simple; user can invert later
      if(mode === 'raster'){
        // row-wise runs (zigzag improvement)
        for(let y=0;y<h;y++){
          let x=0;
          let runs = [];
          while(x<w){
            // find first black pixel in row
            while(x<w && !binary[y*w + x]) x++;
            if(x>=w) break;
            const start = x;
            while(x<w && binary[y*w + x]) x++;
            const end = x-1;
            runs.push([start,end]);
          }
          if(runs.length===0) continue;
          // For efficiency, draw runs in order; use zigzag: even rows left->right, odd rows right->left
          const rowY = y;
          for(const run of runs){
            const sx = run[0], ex = run[1];
            const xStartMM = (sx + 0.0) * pixelMM;
            const xEndMM = (ex + 0.0) * pixelMM;
            const yMM = rowY * pixelMM;
            // rapid to start (pen up)
            lines.push(`G0 X${xStartMM.toFixed(3)} Y${yMM.toFixed(3)} F${feedTravel}`);
            // pen down
            lines.push(`G1 Z${zDown.toFixed(3)} F${feedDraw}`);
            // draw to end
            lines.push(`G1 X${xEndMM.toFixed(3)} Y${yMM.toFixed(3)} F${feedDraw}`);
            // pen up
            lines.push(`G0 Z${zUp.toFixed(3)} F${feedTravel}`);
          }
        }
      } else if(mode === 'contour'){
        // very simple contour: follow the boundary pixels using a basic border tracing
        const visited = new Uint8Array(w*h);
        function neighbours8(px,py){
          const out = [];
          for(let dy=-1;dy<=1;dy++){
            for(let dx=-1;dx<=1;dx++){
              if(dx===0 && dy===0) continue;
              const nx = px+dx, ny = py+dy;
              if(nx<0||nx>=w||ny<0||ny>=h) continue;
              out.push([nx,ny]);
            }
          }
          return out;
        }
        // Moore-Neighbor Tracing (simple)
        function traceBoundary(sx,sy){
          const contour = [];
          let x = sx, y = sy;
          let px = sx-1, py = sy; // previous point (start searching from left)
          let start = true;
          let iter = 0;
          do {
            contour.push([x,y]);
            // find the neighbor of (x,y) starting from prev to take cw order
            let found = false;
            // compute index of previous neighbor in the 8-neighborhood
            const dirs = [
              [-1,0],[-1,-1],[0,-1],[1,-1],[1,0],[1,1],[0,1],[-1,1]
            ]; // cw from left
            // find starting index
            let startIdx = 0;
            for(let i=0;i<8;i++){
              if(x+dirs[i][0] === px && y+dirs[i][1] === py) { startIdx = i; break; }
            }
            // search clockwise from startIdx+1
            for(let k=1;k<=8;k++){
              const idx = (startIdx + k) % 8;
              const nx = x + dirs[idx][0], ny = y + dirs[idx][1];
              if(nx<0||nx>=w||ny<0||ny>=h) continue;
              if(binary[ny*w + nx]){
                // move
                px = x; py = y;
                x = nx; y = ny;
                found = true;
                break;
              }
            }
            if(!found) {
              // no more neighbors: break
              break;
            }
            iter++;
            if(iter> w*h*4) break; // safeguard
            start = false;
          } while(!(x===sx && y===sy));
          return contour;
        }

        for(let y=0;y<h;y++){
          for(let x=0;x<w;x++){
            const i = y*w + x;
            if(binary[i] && !visited[i]){
              // find if pixel has at least one neighboring background pixel (boundary)
              let isBoundary=false;
              for(let oy=-1;oy<=1;oy++){
                for(let ox=-1;ox<=1;ox++){
                  if(ox===0&&oy===0) continue;
                  const nx=x+ox, ny=y+oy;
                  if(nx<0||nx>=w||ny<0||ny>=h) { isBoundary=true; continue; }
                  if(!binary[ny*w + nx]) isBoundary = true;
                }
              }
              if(!isBoundary){
                visited[i]=1;
                continue;
              }
              const contour = traceBoundary(x,y);
              if(contour && contour.length){
                // mark visited roughly
                for(const p of contour){
                  visited[p[1]*w + p[0]] = 1;
                }
                // output contour as moves
                const first = contour[0];
                const x0 = first[0]*pixelMM, y0 = first[1]*pixelMM;
                lines.push(`G0 X${x0.toFixed(3)} Y${y0.toFixed(3)} F${feedTravel}`);
                lines.push(`G1 Z${zDown.toFixed(3)} F${feedDraw}`);
                for(let k=1;k<contour.length;k++){
                  const [cx,cy] = contour[k];
                  lines.push(`G1 X${(cx*pixelMM).toFixed(3)} Y${(cy*pixelMM).toFixed(3)} F${feedDraw}`);
                }
                // close loop
                lines.push(`G1 X${x0.toFixed(3)} Y${y0.toFixed(3)} F${feedDraw}`);
                lines.push(`G0 Z${zUp.toFixed(3)} F${feedTravel}`);
              }
            }
          }
        }
      }

      // finish
      lines.push(`G0 Z${zUp.toFixed(3)} F${feedTravel}`);
      lines.push('M2 ; end');

      lastGcode = lines.join('\n');
      gcodeText.value = lastGcode;
      downloadBtn.disabled = false;
      // scroll to gcode
      gcodeText.scrollTop = 0;
    }

    function downloadGcode(){
      if(!lastGcode) return;
      const blob = new Blob([lastGcode], {type:'text/plain;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'drawing.gcode';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Auto-process if controls change
    thresholdEl.addEventListener('change', () => { if(img && img.width) doProcess(); });
    maxPxEl.addEventListener('change', ()=>{ /* user can re-upload to apply */ });
    widthMMEl.addEventListener('change', ()=>{/* no-op */});

    // Small helper: allow drag & drop
    document.body.addEventListener('dragover', e=>e.preventDefault());
    document.body.addEventListener('drop', e=>{
      e.preventDefault();
      if(e.dataTransfer.files && e.dataTransfer.files[0]){
        fileEl.files = e.dataTransfer.files;
        handleFile();
      }
    });

  </script>
</body>
</html>
